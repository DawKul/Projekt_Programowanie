#include <iostream>

using namespace std;

// Definicja pojedynczego wezla listy
struct Node {
    int data;       // wartosc przechowywana w wezle
    Node* next;     // wskaznik na nastepny wezel
    Node* prev;     // wskaznik na poprzedni wezel
};

// Klasa implementujaca liste dwukierunkowa
class DoublyLinkedList {
private:
    Node* head;     // wskaznik na pierwszy element (glowe)
    Node* tail;     // wskaznik na ostatni element (ogon)

public:
    // Konstruktor - tworzy pusta liste
    DoublyLinkedList() {
        head = nullptr;
        tail = nullptr;
    }

    // Dodanie elementu na poczatek listy
    void addFront(int value) {
        Node* newNode = new Node();   // Tworzymy nowy wezel
        newNode->data = value;        // Ustawiamy jego wartosc
        newNode->next = head;         // Nowy wezel wskazuje na dotychczasowy poczatek
        newNode->prev = nullptr;      // Nowy wezel nie ma poprzednika

        if (head != nullptr) {
            head->prev = newNode;     // Jesli lista nie jest pusta, stary poczatek wskazuje na nowy wezel
        }
        else {
            tail = newNode;           // Jesli lista byla pusta, nowy wezel staje sie takze koncem
        }

        head = newNode;               // Nowy wezel staje sie poczatkiem
    }

    // Dodanie elementu na koniec listy
    void addBack(int value) {
        Node* newNode = new Node();   // Tworzymy nowy wezel
        newNode->data = value;        // Ustawiamy jego wartosc
        newNode->next = nullptr;      // Nowy wezel nie ma nastepcy
        newNode->prev = tail;         // Nowy wezel wskazuje na dotychczasowy koniec

        if (tail != nullptr) {
            tail->next = newNode;     // Jesli lista nie jest pusta, stary koniec wskazuje na nowy wezel
        }
        else {
            head = newNode;           // Jesli lista byla pusta, nowy wezel staje sie takze poczatkiem
        }

        tail = newNode;               // Nowy wezel staje sie koncem
    }

    // Dodanie elementu pod wskazany indeks
    void addAtIndex(int index, int value) {
        if (index == 0) {
            addFront(value);          // Jesli indeks to 0, dodaj na poczatek
            return;
        }

        Node* current = head;
        int count = 0;

        // Przejdz do miejsca w liscie wskazanego przez indeks
        while (current != nullptr && count < index - 1) {
            current = current->next;
            count++;
        }

        if (current == nullptr) {
            cout << "Indeks poza zakresem!" << endl;
            return;
        }

        // Tworzymy nowy wezel i wstawiamy go w odpowiednim miejscu
        Node* newNode = new Node();
        newNode->data = value;
        newNode->next = current->next;
        newNode->prev = current;

        if (current->next != nullptr) {
            current->next->prev = newNode;   // Ustawiamy wskaźnik wsteczny dla nastepnego wezla
        }
        else {
            tail = newNode;                  // Jesli dodajemy na koniec, aktualizujemy ogon
        }

        current->next = newNode;             // Aktualizujemy wskaźnik nastepny dla biezacego wezla
    }

    // Usuniecie elementu z poczatku listy
    void removeFront() {
        if (head == nullptr) return;  // Sprawdzamy, czy lista nie jest pusta

        Node* temp = head;            // Tymczasowo przechowujemy obecny poczatek

        if (head->next != nullptr) {
            head = head->next;        // Ustawiamy nowy poczatek
            head->prev = nullptr;     // Usuwamy wskaznik na poprzedni element
        }
        else {
            head = nullptr;           // Jesli byl to jedyny element, lista staje sie pusta
            tail = nullptr;
        }

        delete temp;                  // Usuwamy stary poczatek
    }

    // Usuniecie elementu z konca listy
    void removeBack() {
        if (tail == nullptr) return;  // Sprawdzamy, czy lista nie jest pusta

        Node* temp = tail;            // Tymczasowo przechowujemy obecny koniec

        if (tail->prev != nullptr) {
            tail = tail->prev;        // Ustawiamy nowy koniec
            tail->next = nullptr;     // Usuwamy wskaznik na nastepny element
        }
        else {
            head = nullptr;           // Jesli byl to jedyny element, lista staje sie pusta
            tail = nullptr;
        }

        delete temp;                  // Usuwamy stary koniec
    }

    // Wyswietlenie wszystkich elementow listy
    void display() {
        Node* current = head;         // Zaczynamy od poczatku
        while (current != nullptr) {
            cout << current->data << " ";  // Wyswietlamy wartosc wezla
            current = current->next;       // Przechodzimy do nastepnego wezla
        }
        cout << endl;
    }

    // Wyswietlenie listy w odwrotnej kolejnosci
    void displayReverse() {
        Node* current = tail;         // Zaczynamy od konca
        while (current != nullptr) {
            cout << current->data << " ";  // Wyswietlamy wartosc wezla
            current = current->prev;       // Przechodzimy do poprzedniego wezla
        }
        cout << endl;
    }

    // Znajdz wezel na podstawie indeksu
    Node* findNode(int index) {
        Node* current = head;
        int count = 0;
        while (current != nullptr && count < index) {
            current = current->next;
            count++;
        }
        return current;  // Zwraca nullptr, jesli indeks poza zasiegiem
    }

    // Wyswietlenie nastepnego elementu
    void displayNext(int index) {
        Node* current = findNode(index);
        if (current != nullptr && current->next != nullptr) {
            cout << "Nastepny element: " << current->next->data << endl;
        }
        else {
            cout << "Brak nastepnego elementu" << endl;
        }
    }

    // Wyswietlenie poprzedniego elementu
    void displayPrev(int index) {
        Node* current = findNode(index);
        if (current != nullptr && current->prev != nullptr) {
            cout << "Poprzedni element: " << current->prev->data << endl;
        }
        else {
            cout << "Brak poprzedniego elementu" << endl;
        }
    }

    // Usuniecie wszystkich elementow listy
    void clear() {
        while (head != nullptr) {     // Dopoki lista nie jest pusta
            removeFront();            // Usuwamy element z poczatku
        }
    }
};

// Program glowny, testowanie listy dwukierunkowej
int main() {
    DoublyLinkedList list;

    list.addFront(10);
    list.addBack(20);
    list.addFront(5);
    list.addBack(30);

    cout << "Lista: ";
    list.display();                   // Wyswietlamy liste

    cout << "Dodajemy element 15 pod indeks 2:" << endl;
    list.addAtIndex(2, 15);           // Dodajemy element o wartosci 15 pod indeks 2
    list.display();                   // Wyswietlamy liste

    cout << "Lista (odwrotnie): ";
    list.displayReverse();            // Wyswietlamy liste w odwrotnej kolejnosci

    list.displayNext(1);              // Wyswietlamy nastepny element wzgledem indeksu 1
    list.displayPrev(2);              // Wyswietlamy poprzedni element wzgledem indeksu 2

    list.removeFront();               // Usuwamy element z poczatku
    cout << "Po usunieciu z poczatku: ";
    list.display();                   // Wyswietlamy liste

    list.removeBack();                // Usuwamy element z konca
    cout << "Po usunieciu z konca: ";
    list.display();                   // Wyswietlamy liste

    list.clear();                     // Usuwamy wszystkie elementy z listy
    cout << "Po wyczyszczeniu: ";
    list.display();                   // Lista powinna byc pusta

    return 0;
}
